<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FurniCraft CAD - Smart Shapes & Alignment</title>
  
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
  <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/exporters/STLExporter.js"></script>

  <style>
    :root {
      --bg-dark: #1e1e1e;
      --bg-panel: #252526;
      --bg-header: #333333;
      --accent: #d35400;
      --select-blue: #007acc; 
      --text-main: #e0e0e0;
      --text-dim: #999;
      --border: #3e3e42;
      --gold: #f1c40f;
      --rec-bg: #2c2918;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: var(--bg-dark);
      color: var(--text-main);
      height: 100vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    /* HEADER */
    header {
      height: 45px;
      background-color: var(--bg-header);
      display: flex;
      align-items: center;
      padding: 0 1rem;
      border-bottom: 1px solid var(--border);
      justify-content: space-between;
    }
    .brand { font-weight: 600; color: white; display: flex; align-items: center; gap: 8px; }
    
    .btn-export {
      background: #e67e22 !important; 
      color: white !important;
      padding: 5px 12px;
      border-radius: 4px;
      font-weight: 600;
      transition: 0.2s;
      display: flex; align-items: center; gap: 6px;
      cursor: pointer; border: none; font-size: 0.9rem;
    }
    .btn-export:hover { background: #d35400 !important; }

    /* WORKSPACE */
    .workspace { display: flex; flex: 1; height: calc(100vh - 45px); }

    /* LEFT SIDEBAR */
    .panel-left {
      width: 220px;
      background-color: var(--bg-panel);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
    }
    .panel-header {
      padding: 12px; font-size: 0.75rem; font-weight: 700; 
      text-transform: uppercase; color: var(--text-dim);
      border-bottom: 1px solid var(--border);
    }
    .scene-list { flex: 1; overflow-y: auto; padding: 5px; }
    .scene-item {
      padding: 10px; margin-bottom: 2px;
      border-radius: 4px; cursor: pointer;
      display: flex; align-items: center; justify-content: space-between;
    }
    .scene-item:hover { background-color: #333; }
    .scene-item.active { background-color: #37373d; border-left: 3px solid var(--accent); }
    .btn-delete { background: none; border: none; color: #666; cursor: pointer; }
    .btn-delete:hover { color: #c0392b; }
    
    .btn-add {
      width: 100%; padding: 12px;
      background: var(--accent); color: white; border: none;
      cursor: pointer; font-weight: 600; display: flex; align-items: center; justify-content: center; gap: 8px;
    }

    /* CENTER VIEWPORT */
    .viewport { flex: 1; position: relative; background: radial-gradient(circle at center, #2d2d30 0%, #1e1e1e 100%); }
    #canvas-container { width: 100%; height: 100%; outline: none; }
    
    /* FLOATING VIEWPORT CONTROLS */
    .viewport-controls {
        position: absolute; top: 15px; left: 50%; transform: translateX(-50%);
        background: rgba(0,0,0,0.6); backdrop-filter: blur(4px);
        padding: 5px; border-radius: 20px; border: 1px solid #555;
        display: flex; gap: 5px; z-index: 10;
    }
    .vp-btn {
        background: transparent; border: none; color: #ddd;
        padding: 8px 15px; border-radius: 15px; cursor: pointer;
        font-size: 0.85rem; display: flex; align-items: center; gap: 6px;
        transition: 0.2s;
    }
    .vp-btn:hover { background: rgba(255,255,255,0.1); color: white; }
    .vp-btn.active { color: var(--accent); }

    /* MODALS */
    .modal-overlay {
      position: absolute; top:0; left:0; width:100%; height:100%;
      background: rgba(0,0,0,0.85); z-index: 100;
      display: none; flex-direction: column; align-items: center; justify-content: center;
      color: white;
    }
    .paywall-card {
        background: #252526; border: 1px solid #d35400; 
        padding: 30px; border-radius: 8px; text-align: center;
        width: 350px; box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    }
    .paywall-price { font-size: 2.5rem; color: white; font-weight: bold; margin: 15px 0; }
    .pay-btn {
        background: #27ae60; color: white; border: none; padding: 12px 24px;
        font-size: 1.1rem; border-radius: 4px; cursor: pointer; width: 100%;
        margin-top: 10px; font-weight: bold;
    }
    .pay-btn:hover { background: #2ecc71; }
    .pay-sub { font-size: 0.8rem; color: #aaa; margin-top: 10px; }

    /* SCORE CARD */
    .score-card {
      position: absolute; top: 60px; right: 10px;
      background: rgba(0,0,0,0.8); padding: 15px; border-radius: 8px;
      width: 200px; border: 1px solid var(--border); pointer-events: none;
    }
    .score-title { font-size: 0.7rem; color: #aaa; text-transform: uppercase; margin-bottom: 8px; }
    .score-row { display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 0.8rem; }
    .score-bar-bg { width: 100%; height: 4px; background: #444; margin-top: 2px; border-radius: 2px; }
    .score-bar-fill { height: 100%; background: var(--accent); border-radius: 2px; transition: width 0.5s; }

    /* RIGHT SIDEBAR */
    .panel-right {
      width: 380px;
      background-color: var(--bg-panel);
      border-left: 1px solid var(--border);
      display: flex;
      flex-direction: column;
    }
    .prop-scroll { flex: 1; overflow-y: auto; }
    .prop-group { padding: 15px; border-bottom: 1px solid var(--border); }
    .prop-label { font-size: 0.75rem; font-weight: 700; color: var(--text-dim); margin-bottom: 8px; display: block; text-transform: uppercase; }

    input[type="text"], select {
      width: 100%; background: #3c3c3c; border: 1px solid var(--border);
      color: white; padding: 8px; border-radius: 4px; font-family: inherit; margin-bottom: 5px;
    }

    .range-row { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; font-size: 0.8rem; }
    .range-row label { width: 50px; }
    input[type="range"] { flex: 1; accent-color: var(--accent); }
    .val-display { width: 35px; text-align: right; color: var(--text-dim); font-size:0.8rem; }

    .mat-section-title { color: var(--gold); font-size: 0.8rem; font-weight: bold; margin: 0 0 8px 0; display: flex; align-items: center; gap: 5px; }
    .mat-grid-large { display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px; margin-bottom: 15px; }
    .mat-card-lg {
      background: #333; border: 1px solid var(--border); border-radius: 4px;
      padding: 8px; text-align: center; cursor: pointer; transition: 0.1s; position: relative;
    }
    .mat-card-lg:hover { transform: translateY(-2px); background: #3e3e42; border-color:white; }
    .mat-card-lg.recommended { background: var(--rec-bg); border-color: #554a1f; }
    
    .mat-card-icon { font-size: 1.2rem; margin-bottom: 4px; }
    .mat-card-name { font-size: 0.7rem; color: #ccc; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

    .layer-item {
      background: #2b2b2b; border-radius: 4px; margin-bottom: 8px; border: 1px solid #333;
      transition: all 0.2s;
    }
    .layer-item.active-layer {
      border: 1px solid var(--select-blue);
      box-shadow: 0 0 8px rgba(0, 122, 204, 0.3);
    }
    .layer-header {
      padding: 10px; display: flex; align-items: center; justify-content: space-between;
      cursor: pointer; background: #333;
    }
    .layer-header:hover { background: #3c3c3c; }
    .color-preview { width: 16px; height: 16px; border-radius: 50%; border: 1px solid #777; }
    .layer-content { display: none; padding: 15px; background: #222; border-top: 1px solid #444; }
    .layer-item.open .layer-content { display: block; }

    .part-control-row { margin-bottom: 15px; }
    .part-control-label { font-size: 0.75rem; color: #aaa; margin-bottom: 5px; display: block; }
    
    .hex-wrapper { display: flex; align-items: center; gap: 8px; }
    input[type="color"] { -webkit-appearance: none; border: none; width: 40px; height: 40px; cursor: pointer; background: none; padding: 0; }
    .hex-text-input { width: 90px !important; margin:0 !important; font-family: monospace; text-transform: uppercase; }

    .dim-row { display: flex; gap: 5px; margin-top: 5px; }
    .dim-group { flex: 1; }
    .dim-input { 
      width: 100%; background: #111; border: 1px solid #444; color: var(--accent); 
      padding: 5px; text-align: center; font-size: 0.8rem; border-radius: 3px;
    }
    .dim-label { font-size: 0.65rem; color: #666; text-align: center; }

    .footer-bar {
      padding: 15px; background: #202020; border-top: 1px solid var(--border);
      display: flex; justify-content: space-between; align-items: center;
    }
    .total-price { font-size: 1.2rem; font-weight: bold; color: var(--accent); }
    
    .instruction-text { font-size: 0.75rem; color: var(--select-blue); margin-bottom: 10px; font-style: italic; }
  </style>
</head>
<body>

  <header>
    <div class="brand">
      <i class="fas fa-cube"></i> FurniCraft Studio
    </div>
    <div class="header-controls">
      <button class="btn-export" onclick="attemptExportSTL()">
        <i class="fas fa-print"></i> Export for 3D Print
      </button>
    </div>
  </header>

  <div class="workspace">

    <aside class="panel-left">
      <div class="panel-header">Scene Explorer</div>
      <div class="scene-list" id="scene-list"></div>
      <button class="btn-add" onclick="addFurniture()">
        <i class="fas fa-plus"></i> Add Furniture
      </button>
    </aside>

    <main class="viewport">
      <div class="viewport-controls">
          <button class="vp-btn" id="btn-rotate" onclick="toggleRotation()">
             <i class="fas fa-pause"></i> Stop Rotate
          </button>
          <button class="vp-btn" onclick="init3D()">
             <i class="fas fa-sync"></i> Reset Cam
          </button>
      </div>

      <div id="canvas-container"></div>
      
      <div id="paywall-overlay" class="modal-overlay">
        <div class="paywall-card">
          <div style="color:#e67e22; font-size:3rem; margin-bottom:10px;"><i class="fas fa-lock"></i></div>
          <h2>Free Limit Reached</h2>
          <p style="color:#aaa; margin-top:10px;">Your first export was free. To continue downloading high-quality miniature STL files, please purchase a license.</p>
          
          <div class="paywall-price">$2.00</div>
          <button class="pay-btn" onclick="simulatePayment()">Pay & Download</button>
          <div class="pay-sub">Secure transaction via FurniPay</div>
          <button onclick="closePaywall()" style="background:none; border:none; color:#666; margin-top:15px; cursor:pointer;">Cancel</button>
        </div>
      </div>
      
      <div class="score-card">
        <div class="score-title">Design Analysis</div>
        <div class="score-row"><span>Durability</span><span id="score-dura-val">0%</span></div>
        <div class="score-bar-bg"><div id="bar-dura" class="score-bar-fill" style="width:0%"></div></div>
        <div class="score-row" style="margin-top:10px;"><span>Material Quality</span><span id="score-qual-val">0%</span></div>
        <div class="score-bar-bg"><div id="bar-qual" class="score-bar-fill" style="width:0%"></div></div>
        <div id="rec-status" style="margin-top:10px; font-size:0.7rem; color:var(--good);"></div>
      </div>
    </main>

    <aside class="panel-right">
      <div class="panel-header">Properties</div>
      <div class="prop-scroll">
        <div class="prop-group">
          <label class="prop-label">Material Library</label>
          <div class="instruction-text">Select a Layer below, then click a Material here to apply.</div>
          <div id="rec-mat-container" style="display:none">
            <div class="mat-section-title"><i class="fas fa-star"></i> Recommended</div>
            <div class="mat-grid-large" id="rec-mat-grid"></div>
          </div>
          <div class="mat-section-title" style="color:#777; margin-top:10px;">All Materials</div>
          <div class="mat-grid-large" id="all-mat-grid"></div>
        </div>

        <div class="prop-group">
          <label class="prop-label">Project Settings</label>
          <input type="text" id="project-name" placeholder="Project Name" oninput="updateProjectName(this.value)">
          <label class="prop-label" style="margin-top:10px">Carving Style (Global)</label>
          <select id="design-style" onchange="updateGlobalCarving(this.value)">
            <option value="none">None (Smooth)</option>
            <option value="floral">Classic Floral (Ukit)</option>
            <option value="geometric">Modern Geometric</option>
            <option value="weave">Rattan Weave</option>
          </select>

          <label class="prop-label" style="margin-top:10px">Global Scale</label>
          <div class="range-row"><label>W</label><input type="range" id="inp-scale-x" min="50" max="200" value="100" oninput="updateGlobalScale('x', this.value)"><span class="val-display" id="gs-x">100</span></div>
          <div class="range-row"><label>H</label><input type="range" id="inp-scale-y" min="50" max="200" value="100" oninput="updateGlobalScale('y', this.value)"><span class="val-display" id="gs-y">100</span></div>
          <div class="range-row"><label>D</label><input type="range" id="inp-scale-z" min="50" max="200" value="100" oninput="updateGlobalScale('z', this.value)"><span class="val-display" id="gs-z">100</span></div>
        </div>

        <div class="prop-group">
          <label class="prop-label">Layers (Select to Edit)</label>
          <div id="layers-container"></div>
        </div>
      </div>
      <div class="footer-bar">
        <span style="font-size:0.8rem; color:#888;">ESTIMATED COST</span>
        <div class="total-price" id="total-price">â‚±0.00</div>
      </div>
    </aside>

  </div>

  <script>
    // --- DATABASE ---
    const materialDB = {
      narra: { name: 'Narra', icon:'ðŸŒ³', hex: '#8B4513', dura: 95, qual: 98, price: 3.5, rec: ['table', 'chair', 'cabinet', 'bed', 'desk'] },
      mahogany: { name: 'Mahogany', icon:'ðŸªµ', hex: '#5c3a21', dura: 85, qual: 90, price: 2.8, rec: ['table', 'bookshelf', 'cabinet'] },
      oak: { name: 'Oak', icon:'ðŸŒ³', hex: '#d4ac7d', dura: 80, qual: 85, price: 2.5, rec: ['bed', 'bookshelf'] },
      steel: { name: 'Steel', icon:'âš™ï¸', hex: '#95a5a6', dura: 99, qual: 80, price: 3.0, rec: ['desk', 'stool'] },
      fabric: { name: 'Fabric', icon:'ðŸ§¶', hex: '#34495e', dura: 60, qual: 85, price: 1.2, rec: ['sofa', 'stool', 'chair'] },
      leather: { name: 'Leather', icon:'ðŸ„', hex: '#2c3e50', dura: 75, qual: 95, price: 4.0, rec: ['sofa', 'chair', 'stool'] },
      plastic: { name: 'Plastic', icon:'â™³', hex: '#ecf0f1', dura: 50, qual: 40, price: 0.5, rec: [] },
      glass: { name: 'Glass', icon:'ðŸ’Ž', hex: '#a8e6cf', dura: 60, qual: 90, price: 2.0, rec: [] },
      white: { name: 'White', icon:'âšª', hex: '#eeeeee', dura: 70, qual: 70, price: 1.0, rec: [] }
    };

    const assetsDB = {
      chair: { name: 'Dining Chair', basePrice: 500, parts: ['Seat', 'Back', 'Legs'] },
      table: { name: 'Dining Table', basePrice: 1500, parts: ['Top', 'Legs'] },
      sofa: { name: 'Sofa', basePrice: 2500, parts: ['Frame', 'Cushions', 'Arms'] },
      cabinet: { name: 'Cabinet', basePrice: 2000, parts: ['Body', 'Doors'] },
      bed: { name: 'Bed Frame', basePrice: 3000, parts: ['Frame', 'Headboard'] },
      bookshelf: { name: 'Bookshelf', basePrice: 1200, parts: ['Frame', 'Shelves'] },
      desk: { name: 'Office Desk', basePrice: 1800, parts: ['Top', 'Legs', 'Drawers'] },
      stool: { name: 'Bar Stool', basePrice: 400, parts: ['Seat', 'Legs'] }
    };

    // --- STATE ---
    let appState = { items: [], activeItemId: 0, activeLayer: null };
    let isRotating = true;
    let textureCache = {}; 

    // --- INIT ---
    window.onload = function() {
      if(!localStorage.getItem('stlExports')) localStorage.setItem('stlExports', '0');

      const newType = sessionStorage.getItem('targetFurniture');
      const savedState = sessionStorage.getItem('cadState');
      
      if (savedState) appState = JSON.parse(savedState);

      if (newType) {
        const newItem = {
          id: Date.now(),
          type: assetsDB[newType] ? newType : 'chair',
          name: assetsDB[newType] ? assetsDB[newType].name : 'Item',
          selections: {}, dims: {}, carvings: {}, shapes: {}, radius: {}, globalScale: { x: 1, y: 1, z: 1 }
        };
        
        assetsDB[newItem.type].parts.forEach(p => {
          newItem.selections[p] = '#8B4513'; 
          newItem.carvings[p] = 'none'; 
          newItem.shapes[p] = 'square'; 
          newItem.radius[p] = 0; 
          
          if(p === 'Legs') { newItem.dims[p] = { w: 5, h: 45, d: 5 }; newItem.shapes[p] = 'square'; }
          else if(p === 'Seat') { newItem.dims[p] = { w: 45, h: 5, d: 45 }; newItem.shapes[p] = 'square'; }
          else if(p === 'Back') newItem.dims[p] = { w: 45, h: 50, d: 5 };
          else if(p === 'Top') { newItem.dims[p] = { w: 120, h: 5, d: 80 }; newItem.shapes[p] = 'square'; }
          else if(p === 'Frame') newItem.dims[p] = { w: 180, h: 30, d: 80 }; 
          else if(p === 'Cushions') { newItem.dims[p] = { w: 160, h: 15, d: 70 }; newItem.shapes[p] = 'round'; }
          else if(p === 'Arms') newItem.dims[p] = { w: 10, h: 50, d: 80 };
          else if(p === 'Body') newItem.dims[p] = { w: 80, h: 120, d: 40 }; 
          else if(p === 'Doors') newItem.dims[p] = { w: 38, h: 110, d: 2 };
          else if(p === 'Headboard') newItem.dims[p] = { w: 180, h: 80, d: 10 };
          else if(p === 'Shelves') newItem.dims[p] = { w: 75, h: 3, d: 28 };
          else if(p === 'Drawers') newItem.dims[p] = { w: 35, h: 40, d: 50 };
          else newItem.dims[p] = { w: 50, h: 50, d: 50 };
        });
        
        appState.items.push(newItem);
        appState.activeItemId = newItem.id;
        sessionStorage.removeItem('targetFurniture');
        saveState();
      }

      if (appState.items.length === 0) {
        if(!confirm("No furniture found. Create default chair?")) return;
        sessionStorage.setItem('targetFurniture', 'chair');
        window.location.reload();
        return;
      }

      const activeItem = appState.items.find(i => i.id === appState.activeItemId);
      if(activeItem && !appState.activeLayer) {
        appState.activeLayer = assetsDB[activeItem.type].parts[0];
      }
      
      if(activeItem) {
          if(!activeItem.carvings) { activeItem.carvings = {}; assetsDB[activeItem.type].parts.forEach(p => activeItem.carvings[p] = 'none'); }
          if(!activeItem.shapes) { activeItem.shapes = {}; assetsDB[activeItem.type].parts.forEach(p => activeItem.shapes[p] = 'square'); }
          if(!activeItem.radius) { activeItem.radius = {}; assetsDB[activeItem.type].parts.forEach(p => activeItem.radius[p] = 0); }
      }

      renderUI();
      init3D();
      updatePrice();
    };

    function saveState() { sessionStorage.setItem('cadState', JSON.stringify(appState)); }

    // --- RENDER UI ---
    function renderUI() {
      renderSceneList();
      renderProperties();
      calculateScore();
      updatePrice();
    }

    function renderSceneList() {
      const list = document.getElementById('scene-list');
      list.innerHTML = '';
      appState.items.forEach((item, index) => {
        const div = document.createElement('div');
        div.className = `scene-item ${item.id === appState.activeItemId ? 'active' : ''}`;
        div.onclick = (e) => { 
          if(e.target.closest('.btn-delete')) return;
          appState.activeItemId = item.id; 
          appState.activeLayer = assetsDB[item.type].parts[0]; 
          renderUI(); build3DScene(); 
        };
        div.innerHTML = `<span><i class="fas fa-cube"></i> ${item.name}</span>
          <button class="btn-delete" onclick="deleteItem(${item.id})"><i class="fas fa-trash-alt"></i></button>`;
        list.appendChild(div);
      });
    }

    function renderProperties() {
      const activeItem = appState.items.find(i => i.id === appState.activeItemId);
      if (!activeItem) return;

      document.getElementById('project-name').value = activeItem.name;
      ['x','y','z'].forEach(axis => {
        const val = Math.round(activeItem.globalScale[axis] * 100);
        document.getElementById(`gs-${axis}`).innerText = val;
        document.getElementById(`inp-scale-${axis}`).value = val;
      });

      const recGrid = document.getElementById('rec-mat-grid');
      const allGrid = document.getElementById('all-mat-grid');
      const recContainer = document.getElementById('rec-mat-container');
      recGrid.innerHTML = ''; allGrid.innerHTML = '';
      
      let hasRecs = false;
      Object.keys(materialDB).forEach(k => {
        const m = materialDB[k];
        const isRec = m.rec.includes(activeItem.type);
        if(isRec) hasRecs = true;

        const card = document.createElement('div');
        card.className = `mat-card-lg ${isRec ? 'recommended' : ''}`;
        card.onclick = () => applyMaterialToActiveLayer(m.hex);
        
        card.innerHTML = `<div class="mat-card-icon">${m.icon}</div><div class="mat-card-name">${m.name}</div>`;
        if(isRec) recGrid.appendChild(card);
        else allGrid.appendChild(card);
      });
      recContainer.style.display = hasRecs ? 'block' : 'none';

      const container = document.getElementById('layers-container');
      container.innerHTML = '';
      const assetDef = assetsDB[activeItem.type];
      
      assetDef.parts.forEach(part => {
        const hex = activeItem.selections[part];
        const dims = activeItem.dims[part] || {w:50,h:50,d:50};
        const currentCarving = activeItem.carvings ? activeItem.carvings[part] : 'none';
        const currentShape = activeItem.shapes ? activeItem.shapes[part] : 'square';
        const currentRadius = activeItem.radius ? activeItem.radius[part] : 0;
        const isActive = (appState.activeLayer === part);

        const layer = document.createElement('div');
        layer.className = `layer-item ${isActive ? 'active-layer open' : ''}`;
        
        layer.onclick = (e) => {
            if(e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
            setActiveLayer(part);
        };

        const carvingOptions = [
            {v:'none', t:'None (Smooth)'},
            {v:'floral', t:'Classic Floral'},
            {v:'geometric', t:'Geometric'},
            {v:'linear', t:'Linear Grooves'},
            {v:'lattice', t:'Diamond Lattice'},
            {v:'studded', t:'Studded/Tufted'},
            {v:'weave', t:'Basket Weave'},
            {v:'rustic', t:'Rustic/Aged'}
        ].map(opt => `<option value="${opt.v}" ${currentCarving===opt.v ? 'selected' : ''}>${opt.t}</option>`).join('');

        const shapeOptions = [
            {v:'square', t:'Box / Square'},
            {v:'round', t:'Cylinder / Round'},
            {v:'hex', t:'Hexagon'},
            {v:'oct', t:'Octagon'},
            {v:'tapered', t:'Tapered'},
            {v:'bun', t:'Bun / Flattened Sphere'}
        ].map(opt => `<option value="${opt.v}" ${currentShape===opt.v ? 'selected' : ''}>${opt.t}</option>`).join('');

        const showRadius = (currentShape === 'square') ? 'block' : 'none';

        layer.innerHTML = `
          <div class="layer-header">
            <span><i class="fas fa-layer-group"></i> ${part} ${isActive ? '(Selected)' : ''}</span>
            <div class="color-preview" style="background:${hex}"></div>
          </div>
          <div class="layer-content">
            
            <div class="part-control-row">
                <span class="part-control-label">Shape</span>
                <select onchange="updateLayerShape('${part}', this.value)">
                    ${shapeOptions}
                </select>
            </div>

            <div class="part-control-row" style="display:${showRadius}">
                <div class="range-row">
                    <label style="width:auto; font-size:0.75rem; color:#aaa; margin-right:10px;">Corner Radius</label>
                    <input type="range" min="0" max="50" value="${currentRadius}" oninput="updateLayerRadius('${part}', this.value)">
                    <span class="val-display">${currentRadius}%</span>
                </div>
            </div>

            <div class="part-control-row">
                <span class="part-control-label">Carving / Texture</span>
                <select onchange="updateLayerCarving('${part}', this.value)">
                    ${carvingOptions}
                </select>
            </div>

            <div class="part-control-row">
              <span class="part-control-label">Hex Color</span>
              <div class="hex-wrapper">
                <input type="color" value="${hex}" oninput="updateColor('${part}', this.value)">
                <input type="text" class="hex-text-input" value="${hex}" onchange="updateColor('${part}', this.value)">
              </div>
            </div>
            
            <div class="part-control-row">
              <span class="part-control-label">Dimensions (cm)</span>
              <div class="dim-row">
                <div class="dim-group"><input class="dim-input" type="number" value="${dims.w}" oninput="updateDim('${part}','w',this.value)"><div class="dim-label">W</div></div>
                <div class="dim-group"><input class="dim-input" type="number" value="${dims.h}" oninput="updateDim('${part}','h',this.value)"><div class="dim-label">H</div></div>
                <div class="dim-group"><input class="dim-input" type="number" value="${dims.d}" oninput="updateDim('${part}','d',this.value)"><div class="dim-label">D</div></div>
              </div>
            </div>
          </div>
        `;
        container.appendChild(layer);
      });
    }

    function setActiveLayer(partName) {
        appState.activeLayer = partName;
        renderProperties(); 
    }

    function toggleRotation() {
      isRotating = !isRotating;
      if(controls) controls.autoRotate = isRotating;
      
      const btn = document.getElementById('btn-rotate');
      if(isRotating) {
        btn.innerHTML = '<i class="fas fa-pause"></i> Stop Rotate';
      } else {
        btn.innerHTML = '<i class="fas fa-play"></i> Auto Rotate';
      }
    }

    function applyMaterialToActiveLayer(hex) {
        if(!appState.activeLayer) {
            alert("Please select a Layer below first.");
            return;
        }
        updateColor(appState.activeLayer, hex);
        renderProperties();
    }

    function updateColor(part, hex) {
      const activeItem = appState.items.find(i => i.id === appState.activeItemId);
      activeItem.selections[part] = hex;
      build3DScene();
      saveState();
      calculateScore();
      updatePrice();
    }

    function updateDim(part, axis, val) {
      const activeItem = appState.items.find(i => i.id === appState.activeItemId);
      if(!activeItem.dims[part]) activeItem.dims[part] = {w:50, h:50, d:50};
      activeItem.dims[part][axis] = parseInt(val) || 0;
      saveState();
      build3DScene(); 
      updatePrice(); 
    }

    function updateGlobalCarving(style) {
        const activeItem = appState.items.find(i => i.id === appState.activeItemId);
        if(!activeItem.carvings) activeItem.carvings = {};
        Object.keys(activeItem.selections).forEach(part => {
             activeItem.carvings[part] = style;
        });
        saveState();
        renderProperties();
        build3DScene();
    }

    function updateLayerCarving(part, style) {
        const activeItem = appState.items.find(i => i.id === appState.activeItemId);
        if(!activeItem.carvings) activeItem.carvings = {};
        activeItem.carvings[part] = style;
        saveState();
        build3DScene(); 
    }

    function updateLayerShape(part, shape) {
        const activeItem = appState.items.find(i => i.id === appState.activeItemId);
        if(!activeItem.shapes) activeItem.shapes = {};
        activeItem.shapes[part] = shape;
        saveState();
        renderProperties(); 
        build3DScene(); 
    }

    function updateLayerRadius(part, val) {
        const activeItem = appState.items.find(i => i.id === appState.activeItemId);
        if(!activeItem.radius) activeItem.radius = {};
        activeItem.radius[part] = parseInt(val);
        saveState();
        document.querySelector('.val-display').innerText = val + "%"; 
        build3DScene(); 
    }

    function updateGlobalScale(axis, val) {
      const scale = val / 100;
      document.getElementById(`gs-${axis}`).innerText = val;
      const activeItem = appState.items.find(i => i.id === appState.activeItemId);
      activeItem.globalScale[axis] = scale;
      if(currentGroup) {
          currentGroup.scale.set(activeItem.globalScale.x, activeItem.globalScale.y, activeItem.globalScale.z);
      }
      build3DScene();
      updatePrice(); 
    }

    function updateProjectName(val) {
        const activeItem = appState.items.find(i => i.id === appState.activeItemId);
        activeItem.name = val;
    }

    function updatePrice() {
      const activeItem = appState.items.find(i => i.id === appState.activeItemId);
      if(!activeItem) return;

      const basePrice = assetsDB[activeItem.type].basePrice;
      let addedMaterialCost = 0;
      
      const parts = Object.keys(activeItem.selections);
      parts.forEach(part => {
         const hex = activeItem.selections[part];
         const matKey = Object.keys(materialDB).find(k => materialDB[k].hex.toLowerCase() === hex.toLowerCase()) || 'plastic';
         const matData = materialDB[matKey] || materialDB['plastic'];
         const d = activeItem.dims[part] || {w:50,h:50,d:50};
         const volumeFactor = (d.w * d.h * d.d) / 5000; 
         addedMaterialCost += volumeFactor * matData.price;
      });

      const scaleMultiplier = (activeItem.globalScale.x * activeItem.globalScale.y * activeItem.globalScale.z);
      const totalPrice = (basePrice + addedMaterialCost) * scaleMultiplier;

      document.getElementById('total-price').innerText = 'â‚±' + Math.round(totalPrice).toLocaleString();
    }

    function calculateScore() {
      const activeItem = appState.items.find(i => i.id === appState.activeItemId);
      const parts = Object.values(activeItem.selections);
      let totalDura = 0, totalQual = 0, recCount = 0;
      parts.forEach(hex => {
        const matKey = Object.keys(materialDB).find(k => materialDB[k].hex.toLowerCase() === hex.toLowerCase());
        if(matKey) {
          const mat = materialDB[matKey];
          totalDura += mat.dura; totalQual += mat.qual;
          if(mat.rec.includes(activeItem.type)) recCount++;
        } else { totalDura += 50; totalQual += 50; }
      });
      const avgDura = Math.round(totalDura / parts.length) || 0;
      const avgQual = Math.round(totalQual / parts.length) || 0;

      document.getElementById('bar-dura').style.width = avgDura + '%';
      document.getElementById('score-dura-val').innerText = avgDura + '%';
      document.getElementById('bar-dura').style.background = avgDura > 80 ? '#2ecc71' : (avgDura > 50 ? 'orange' : '#e74c3c');
      document.getElementById('bar-qual').style.width = avgQual + '%';
      document.getElementById('score-qual-val').innerText = avgQual + '%';
      
      const statusEl = document.getElementById('rec-status');
      if(recCount === parts.length) statusEl.innerHTML = '<i class="fas fa-check-circle"></i> Optimal Choice';
      else statusEl.innerHTML = '<i class="fas fa-info-circle"></i> Custom Mix';
    }

    function deleteItem(id) {
      if(confirm('Delete?')) {
        appState.items = appState.items.filter(i => i.id !== id);
        if(appState.items.length === 0) window.location.href = 'craft.html';
        else appState.activeItemId = appState.items[0].id;
        saveState(); renderUI(); build3DScene();
      }
    }
    
    function addFurniture() { saveState(); window.location.href = 'craft.html'; }

    // --- TEXTURE GENERATOR ---
    function createPatternTexture(style) {
        if(textureCache[style]) return textureCache[style];
        const canvas = document.createElement('canvas');
        canvas.width = 512; canvas.height = 512;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#808080'; ctx.fillRect(0,0,512,512);
        ctx.strokeStyle = '#ffffff'; ctx.fillStyle = '#ffffff'; ctx.lineWidth = 15;

        if (style === 'linear') {
            for(let i=0; i<=512; i+=64) { ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(512, i); ctx.stroke(); }
        } else if (style === 'lattice') {
            ctx.beginPath();
            for(let i=-512; i<1024; i+=64) { ctx.moveTo(i, 0); ctx.lineTo(i+512, 512); ctx.moveTo(i, 512); ctx.lineTo(i+512, 0); }
            ctx.stroke();
        } else if (style === 'studded') {
            for(let x=25; x<512; x+=100) for(let y=25; y<512; y+=100) {
                const grad = ctx.createRadialGradient(x,y,5,x,y,40); grad.addColorStop(0, "white"); grad.addColorStop(1, "#808080");
                ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(x,y,35,0,Math.PI*2); ctx.fill();
            }
        } else if (style === 'geometric') {
            ctx.lineWidth = 10; ctx.strokeRect(50,50,412,412); ctx.strokeRect(150,150,212,212); ctx.beginPath(); ctx.arc(256,256,60,0,Math.PI*2); ctx.stroke();
        } else if (style === 'floral') {
            ctx.beginPath(); ctx.moveTo(256, 50); ctx.bezierCurveTo(150, 50, 150, 200, 256, 200); ctx.bezierCurveTo(362, 200, 362, 50, 256, 50);
            ctx.moveTo(256, 462); ctx.bezierCurveTo(150, 462, 150, 312, 256, 312); ctx.bezierCurveTo(362, 312, 362, 462, 256, 462); ctx.fill();
            ctx.lineWidth = 8; ctx.beginPath(); ctx.arc(100,256,50,0,Math.PI*2); ctx.stroke(); ctx.beginPath(); ctx.arc(412,256,50,0,Math.PI*2); ctx.stroke();
        } else if (style === 'weave') {
             for(let i=0; i<512; i+=40) { ctx.fillStyle = (i%80===0) ? '#ffffff' : '#a0a0a0'; ctx.fillRect(i, 0, 30, 512); ctx.fillStyle = (i%80!==0) ? '#ffffff' : '#a0a0a0'; ctx.fillRect(0, i, 512, 30); }
        } else if (style === 'rustic') {
            for(let i=0; i<5000; i++) { const x = Math.random()*512; const y = Math.random()*512; const s = Math.random()*4; ctx.fillRect(x,y,s,s*4); }
        }
        const texture = new THREE.CanvasTexture(canvas);
        texture.wrapS = THREE.RepeatWrapping; texture.wrapT = THREE.RepeatWrapping;
        textureCache[style] = texture;
        return texture;
    }

    // --- 3D ENGINE ---
    let scene, camera, renderer, currentGroup, controls, dimGroup;
    let animationId; 

    function init3D() {
      const container = document.getElementById('canvas-container');
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1e1e1e);
      camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 100);
      camera.position.set(8, 6, 10);
      
      renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      container.innerHTML = ''; container.appendChild(renderer.domElement);
      
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true; 
      controls.autoRotate = isRotating; 
      controls.autoRotateSpeed = 0.5;
      
      const ambient = new THREE.AmbientLight(0xffffff, 0.4);
      scene.add(ambient);

      const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
      dirLight.position.set(5, 10, 7);
      dirLight.castShadow = true;
      dirLight.shadow.mapSize.width = 1024; 
      dirLight.shadow.mapSize.height = 1024;
      scene.add(dirLight);

      const fillLight = new THREE.DirectionalLight(0xffeedd, 0.5);
      fillLight.position.set(-5, 5, -5);
      scene.add(fillLight);
      
      scene.add(new THREE.GridHelper(20, 20, 0x444444, 0x2a2a2a));
      dimGroup = new THREE.Group(); scene.add(dimGroup);
      
      build3DScene(); 
      animate();
    }

    // --- HELPER FOR MEASUREMENT LINES ---
    function createDimensionLine(start, end, label, offset = new THREE.Vector3(0,0,0)) {
        const p1 = start.clone().add(offset);
        const p2 = end.clone().add(offset);
        
        const points = [p1, p2];
        const geo = new THREE.BufferGeometry().setFromPoints(points);
        const mat = new THREE.LineBasicMaterial({ color: 0xaaaaaa, transparent: true, opacity: 0.5 });
        const line = new THREE.Line(geo, mat);

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 512; canvas.height = 128; 
        ctx.fillStyle = "rgba(0,0,0,0)"; 
        ctx.fillRect(0,0,512,128);
        ctx.font = "Bold 60px Segoe UI, Arial, sans-serif"; 
        ctx.fillStyle = "#ffffff"; 
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.shadowColor = "rgba(0,0,0,0.8)";
        ctx.shadowBlur = 4;
        ctx.fillText(label, 256, 64);
        
        const tex = new THREE.CanvasTexture(canvas);
        const spriteMat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false });
        const sprite = new THREE.Sprite(spriteMat);
        
        sprite.position.copy(p1).lerp(p2, 0.5);
        sprite.position.y += 0.05; 
        sprite.scale.set(0.6, 0.15, 1);

        const group = new THREE.Group();
        group.add(line);
        group.add(sprite);
        
        const tickSize = 0.05; 
        const isVertical = Math.abs(p1.y - p2.y) > Math.abs(p1.x - p2.x);
        let t1Start, t1End, t2Start, t2End;
        
        if (isVertical) {
            t1Start = new THREE.Vector3(p1.x - tickSize, p1.y, p1.z);
            t1End   = new THREE.Vector3(p1.x + tickSize, p1.y, p1.z);
            t2Start = new THREE.Vector3(p2.x - tickSize, p2.y, p2.z);
            t2End   = new THREE.Vector3(p2.x + tickSize, p2.y, p2.z);
        } else {
            t1Start = new THREE.Vector3(p1.x, p1.y - tickSize, p1.z);
            t1End   = new THREE.Vector3(p1.x, p1.y + tickSize, p1.z);
            t2Start = new THREE.Vector3(p2.x, p2.y - tickSize, p2.z);
            t2End   = new THREE.Vector3(p2.x, p2.y + tickSize, p2.z);
        }

        const t1Geo = new THREE.BufferGeometry().setFromPoints([t1Start, t1End]);
        const t2Geo = new THREE.BufferGeometry().setFromPoints([t2Start, t2End]);
        group.add(new THREE.Line(t1Geo, mat));
        group.add(new THREE.Line(t2Geo, mat));

        return group;
    }

    function build3DScene() {
      if(currentGroup) scene.remove(currentGroup);
      dimGroup.clear(); 

      currentGroup = new THREE.Group();
      const activeItem = appState.items.find(i => i.id === appState.activeItemId);
      if(!activeItem) return;
      
      if(!activeItem.carvings) activeItem.carvings = {};
      if(!activeItem.shapes) activeItem.shapes = {};
      if(!activeItem.radius) activeItem.radius = {};

      const SCALE_FACTOR = 50; 

      const getDims = (part) => {
          const d = activeItem.dims[part] || { w:50, h:50, d:50 };
          return { w: d.w / SCALE_FACTOR, h: d.h / SCALE_FACTOR, d: d.d / SCALE_FACTOR };
      };

      const make = (name, x, y, z) => {
        const hex = activeItem.selections[name] || '#888888';
        const partStyle = activeItem.carvings[name] || 'none';
        const shape = activeItem.shapes[name] || 'square';
        const radiusPercent = activeItem.radius[name] || 0;
        const d = getDims(name);
        
        let geo;
        
        if(shape === 'square' && radiusPercent > 0) {
            const rectW = d.w; const rectD = d.d; const extrudeH = d.h;
            const maxR = Math.min(rectW, rectD) / 2;
            const r = (radiusPercent / 100) * maxR;
            
            const shapeObj = new THREE.Shape();
            const hw = rectW/2; const hd = rectD/2;
            shapeObj.moveTo(-hw + r, -hd);
            shapeObj.lineTo(hw - r, -hd);
            shapeObj.quadraticCurveTo(hw, -hd, hw, -hd + r);
            shapeObj.lineTo(hw, hd - r);
            shapeObj.quadraticCurveTo(hw, hd, hw - r, hd);
            shapeObj.lineTo(-hw + r, hd);
            shapeObj.quadraticCurveTo(-hw, hd, -hw, hd - r);
            shapeObj.lineTo(-hw, -hd + r);
            shapeObj.quadraticCurveTo(-hw, -hd, -hw + r, -hd);

            const extrudeSettings = { steps: 1, depth: extrudeH, bevelEnabled: false };
            geo = new THREE.ExtrudeGeometry(shapeObj, extrudeSettings);
            geo.translate(0, 0, -extrudeH/2);
            geo.rotateX(Math.PI/2);
            
            const pos = geo.attributes.position; const uv = geo.attributes.uv;
            for (let i = 0; i < pos.count; i++) {
                const px = pos.getX(i); const py = pos.getY(i); const pz = pos.getZ(i);
                uv.setXY(i, (px + hw) / (2*hw), (pz + hd) / (2*hd)); 
            }
        }
        else if(shape === 'round') {
            geo = new THREE.CylinderGeometry(Math.min(d.w, d.d)/2, Math.min(d.w, d.d)/2, d.h, 32);
        }
        else if(shape === 'hex') {
            geo = new THREE.CylinderGeometry(Math.min(d.w, d.d)/2, Math.min(d.w, d.d)/2, d.h, 6);
        }
        else if(shape === 'oct') {
            geo = new THREE.CylinderGeometry(Math.min(d.w, d.d)/2, Math.min(d.w, d.d)/2, d.h, 8);
        }
        else if(shape === 'tapered') {
            geo = new THREE.CylinderGeometry(Math.min(d.w, d.d)/3, Math.min(d.w, d.d)/2, d.h, 32);
        }
        else if(shape === 'bun') {
            geo = new THREE.SphereGeometry(Math.min(d.w, d.d)/2, 32, 32);
            geo.scale(1, 0.6, 1); // Flatten for bun foot
        }
        else {
            geo = new THREE.BoxGeometry(d.w, d.h, d.d);
        }

        const mat = new THREE.MeshStandardMaterial({ color: hex, roughness: 0.4, metalness: 0.1 });

        if(partStyle !== 'none') {
             const tex = createPatternTexture(partStyle).clone();
             let repeatX, repeatY;
             if (shape !== 'square') { repeatX = Math.max(1, d.w * 3); repeatY = Math.max(1, d.h * 2); } 
             else { repeatX = Math.max(1, d.w * 2); repeatY = Math.max(1, d.h * 2); }
             tex.repeat.set(repeatX, repeatY); tex.needsUpdate = true;
             mat.bumpMap = tex; mat.bumpScale = 0.15;
        }

        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(x, y, z);
        mesh.name = name;
        mesh.castShadow = true; mesh.receiveShadow = true;
        currentGroup.add(mesh);
      };

      const type = activeItem.type;
      
      const sX = activeItem.globalScale.x;
      const sY = activeItem.globalScale.y;
      const sZ = activeItem.globalScale.z;

      // Helper to determine inset for connected parts (feet/legs) based on top shape
      const getInsetScale = (partName) => {
          const s = activeItem.shapes[partName];
          if(s === 'round' || s === 'hex' || s === 'oct' || s === 'bun' || s === 'tapered') return 0.70; // Inset legs for round/poly tops
          return 1.0;
      };

      // --- BUILD GEOMETRY & ADD MEASUREMENTS ---
      if (type === 'table' || type === 'desk') {
          const dTop = getDims('Top');
          const dLeg = getDims('Legs');
          
          // Smart Inset Calculation
          const insetScale = getInsetScale('Top');
          
          const locX = ((dTop.w / 2) - (dLeg.w / 2)) * insetScale;
          const locZ = ((dTop.d / 2) - (dLeg.d / 2)) * insetScale;
          const yLeg = dLeg.h / 2;
          const yTop = dLeg.h + (dTop.h / 2);

          make('Legs', -locX, yLeg, -locZ);
          make('Legs',  locX, yLeg, -locZ);
          make('Legs', -locX, yLeg,  locZ);
          make('Legs',  locX, yLeg,  locZ);
          make('Top', 0, yTop, 0);

          if(type === 'desk') {
             const dDraw = getDims('Drawers');
             if(dDraw) {
                 // Adjust drawer position if table is round to prevent sticking out
                 // FIX: Do NOT multiply by insetScale here. Drawers are side-mounted (Axis), not corner-mounted.
                 const drawX = ((dTop.w / 2) - (dDraw.w / 2) - 0.1); 
                 const drawY = (dDraw.h / 2); 
                 make('Drawers', drawX, drawY, 0);
             }
          }

          // ** MEASUREMENTS **
          const totalH = dLeg.h + dTop.h;
          dimGroup.add(createDimensionLine(
              new THREE.Vector3(locX + dLeg.w/2 + 0.1, 0, locZ + dLeg.d/2), 
              new THREE.Vector3(locX + dLeg.w/2 + 0.1, totalH, locZ + dLeg.d/2), 
              (totalH * 50 * sY).toFixed(0) + "cm"
          ));

          dimGroup.add(createDimensionLine(
              new THREE.Vector3(-locX - dLeg.w/2 - 0.1, 0, -locZ), 
              new THREE.Vector3(-locX - dLeg.w/2 - 0.1, dLeg.h, -locZ), 
              (dLeg.h * 50 * sY).toFixed(0) + "cm"
          ));

          dimGroup.add(createDimensionLine(
              new THREE.Vector3(-dTop.w/2, totalH + 0.1, -dTop.d/2), 
              new THREE.Vector3(dTop.w/2, totalH + 0.1, -dTop.d/2), 
              (dTop.w * 50 * sX).toFixed(0) + "cm"
          ));
      } 
      else if (type === 'chair' || type === 'stool') {
          const dSeat = getDims('Seat');
          const dLeg = getDims('Legs');
          
          // Smart Inset
          const insetScale = getInsetScale('Seat');

          const locX = ((dSeat.w / 2) - (dLeg.w / 2)) * insetScale;
          const locZ = ((dSeat.d / 2) - (dLeg.d / 2)) * insetScale;
          const yLeg = dLeg.h / 2;
          const ySeat = dLeg.h + (dSeat.h / 2);

          make('Legs', -locX, yLeg, -locZ);
          make('Legs',  locX, yLeg, -locZ);
          make('Legs', -locX, yLeg,  locZ);
          make('Legs',  locX, yLeg,  locZ);
          make('Seat', 0, ySeat, 0);

          if(type === 'chair') {
              const dBack = getDims('Back');
              // Push back rest to the edge of the seat, respecting shape
              const backZ = (-(dSeat.d / 2) + (dBack.d / 2)) * (insetScale > 0.9 ? 1 : 0.85); 
              const backY = dLeg.h + dSeat.h + (dBack.h / 2);
              make('Back', 0, backY, backZ);

              const totalH = dLeg.h + dSeat.h + dBack.h;
              dimGroup.add(createDimensionLine(
                  new THREE.Vector3(locX + 0.1, dLeg.h + dSeat.h, backZ),
                  new THREE.Vector3(locX + 0.1, totalH, backZ),
                  (dBack.h * 50 * sY).toFixed(0) + "cm"
              ));
          }

          const seatTopY = dLeg.h + dSeat.h;
          dimGroup.add(createDimensionLine(
              new THREE.Vector3(-locX - 0.1, 0, locZ),
              new THREE.Vector3(-locX - 0.1, seatTopY, locZ),
              (seatTopY * 50 * sY).toFixed(0) + "cm"
          ));
          
          dimGroup.add(createDimensionLine(
             new THREE.Vector3(-dSeat.w/2, 0.1, dSeat.d/2 + 0.1),
             new THREE.Vector3(dSeat.w/2, 0.1, dSeat.d/2 + 0.1),
             (dSeat.w * 50 * sX).toFixed(0) + "cm"
          ));
      }
      else if (type === 'sofa') {
          const dFrame = getDims('Frame');
          const dCush = getDims('Cushions');
          const dArm = getDims('Arms');
          
          make('Frame', 0, dFrame.h/2, 0);
          
          const backH = dFrame.h * 1.5;
          const backD = dFrame.d * 0.2;
          make('Frame', 0, dFrame.h + backH/2, -(dFrame.d/2) + (backD/2));
          
          const yCush = dFrame.h + (dCush.h / 2);
          make('Cushions', 0, yCush, 0);
          
          const armLocX = (dFrame.w / 2) + (dArm.w / 2);
          make('Arms', -armLocX, (dArm.h/2), 0);
          make('Arms', armLocX, (dArm.h/2), 0);

          const totalW = dFrame.w + (dArm.w * 2);
          dimGroup.add(createDimensionLine(
              new THREE.Vector3(-totalW/2, 0, dFrame.d/2 + 0.2),
              new THREE.Vector3(totalW/2, 0, dFrame.d/2 + 0.2),
              (totalW * 50 * sX).toFixed(0) + "cm"
          ));
      }
      else if (type === 'bed') {
          const dFrame = getDims('Frame');
          const dHead = getDims('Headboard');
          
          make('Frame', 0, dFrame.h/2, 0);
          
          const headZ = -(dFrame.d / 2) + (dHead.d / 2);
          const headH = dHead.h * 2; 
          make('Headboard', 0, headH/2, headZ);
          
          dimGroup.add(createDimensionLine(
              new THREE.Vector3(-dFrame.w/2, 0, dFrame.d/2 + 0.2),
              new THREE.Vector3(dFrame.w/2, 0, dFrame.d/2 + 0.2),
              (dFrame.w * 50 * sX).toFixed(0) + "cm"
          ));
      }
      else if (type === 'cabinet') {
          const dBody = getDims('Body');
          const dDoors = getDims('Doors');
          
          make('Body', 0, dBody.h/2, 0);
          
          const doorW = (dBody.w / 2) - 0.05; 
          const doorH = dBody.h - 0.2; 
          const doorZ = (dBody.d / 2) + (dDoors.d / 2);
          
          make('Doors', -doorW/2 - 0.02, dBody.h/2, doorZ); 
          make('Doors', doorW/2 + 0.02, dBody.h/2, doorZ); 
          
          dimGroup.add(createDimensionLine(
              new THREE.Vector3(-dBody.w/2, 0, doorZ + 0.2),
              new THREE.Vector3(dBody.w/2, 0, doorZ + 0.2),
              (dBody.w * 50 * sX).toFixed(0) + "cm"
          ));
          dimGroup.add(createDimensionLine(
              new THREE.Vector3(dBody.w/2 + 0.2, 0, doorZ),
              new THREE.Vector3(dBody.w/2 + 0.2, dBody.h, doorZ),
              (dBody.h * 50 * sY).toFixed(0) + "cm"
          ));
      }
      else if (type === 'bookshelf') {
          const dFrame = getDims('Frame');
          const sideW = 0.1; 
          make('Frame', -(dFrame.w/2) + sideW/2, dFrame.h/2, 0); 
          make('Frame', (dFrame.w/2) - sideW/2, dFrame.h/2, 0); 
          
          const backD = 0.05;
          make('Frame', 0, dFrame.h/2, -(dFrame.d/2) + backD/2);
          
          const numShelves = 4;
          const spacing = dFrame.h / (numShelves + 1);
          for(let i=1; i<=numShelves; i++) {
              make('Shelves', 0, i * spacing, 0);
          }
          
          dimGroup.add(createDimensionLine(
              new THREE.Vector3(-dFrame.w/2, 0, dFrame.d/2 + 0.2),
              new THREE.Vector3(dFrame.w/2, 0, dFrame.d/2 + 0.2),
              (dFrame.w * 50 * sX).toFixed(0) + "cm"
          ));
          dimGroup.add(createDimensionLine(
              new THREE.Vector3(dFrame.w/2 + 0.2, 0, dFrame.d/2),
              new THREE.Vector3(dFrame.w/2 + 0.2, dFrame.h, dFrame.d/2),
              (dFrame.h * 50 * sY).toFixed(0) + "cm"
          ));
      }
      else {
          let currentY = 0;
          let maxW = 0, maxD = 0;
          assetsDB[activeItem.type].parts.forEach(p => {
              const dim = getDims(p);
              make(p, 0, currentY + dim.h/2, 0);
              currentY += dim.h;
              maxW = Math.max(maxW, dim.w);
              maxD = Math.max(maxD, dim.d);
          });
          dimGroup.add(createDimensionLine(
              new THREE.Vector3(maxW/2 + 0.1, 0, 0),
              new THREE.Vector3(maxW/2 + 0.1, currentY, 0),
              (currentY * 50 * sY).toFixed(0) + "cm"
          ));
      }

      currentGroup.scale.set(activeItem.globalScale.x, activeItem.globalScale.y, activeItem.globalScale.z);
      dimGroup.scale.copy(currentGroup.scale);
      
      scene.add(currentGroup);
    }

    function animate() {
      requestAnimationFrame(animate);
      if(controls) controls.update();
      renderer.render(scene, camera);
    }
    
    // --- PAYWALL & EXPORT STL LOGIC ---

    function attemptExportSTL() {
        const exports = parseInt(localStorage.getItem('stlExports'));
        if (exports > 0) {
            document.getElementById('paywall-overlay').style.display = 'flex';
        } else {
            exportSTL();
        }
    }

    function simulatePayment() {
        const btn = document.querySelector('.pay-btn');
        btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processing...';
        setTimeout(() => {
            alert("Payment Successful! Downloading...");
            closePaywall();
            exportSTL();
            btn.innerHTML = 'Pay & Download';
        }, 1500);
    }

    function closePaywall() {
        document.getElementById('paywall-overlay').style.display = 'none';
    }

    function exportSTL() {
        const exporter = new THREE.STLExporter();
        const options = { binary: true }; 
        const originalRot = currentGroup.rotation.y;
        currentGroup.rotation.y = 0;
        const result = exporter.parse(currentGroup, options);
        currentGroup.rotation.y = originalRot;
        
        let exports = parseInt(localStorage.getItem('stlExports'));
        localStorage.setItem('stlExports', exports + 1);

        const blob = new Blob([result], { type: 'application/octet-stream' });
        const link = document.createElement('a');
        link.style.display = 'none';
        document.body.appendChild(link);
        
        const activeItem = appState.items.find(i => i.id === appState.activeItemId);
        link.href = URL.createObjectURL(blob);
        link.download = `FurniCraft_${activeItem.name}_1-12Scale.stl`; 
        link.click();
        document.body.removeChild(link);
    }
  </script>
</body>
</html>